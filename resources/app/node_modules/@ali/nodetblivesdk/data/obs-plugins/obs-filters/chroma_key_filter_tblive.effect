uniform float4x4 ViewProj;
uniform texture2d image;


uniform float4 color;
uniform float contrast;
uniform float brightness;
uniform float gamma;
uniform float2 chroma_key;
uniform float4 key_rgb;
uniform float2 pixel_size;

uniform float similarity;    
uniform float smoothness;
uniform float spill; 

sampler_state textureSampler {
	Filter    = Linear;
	AddressU  = Clamp;
	AddressV  = Clamp;
};

struct VertData {
	float4 pos : POSITION;
	float2 uv  : TEXCOORD0;
};

VertData VSDefault(VertData v_in)
{
	VertData vert_out;
	vert_out.pos = mul(float4(v_in.pos.xyz, 1.0), ViewProj);
	vert_out.uv  = v_in.uv;
	return vert_out;
}

float2 get_base_alpha(float3 input_rgb)
{
    float base_alpha;
    float color_distance;
    
    
    if( (input_rgb.g - input_rgb.r > similarity) &&
        (input_rgb.g - input_rgb.b > similarity) )
    {
        base_alpha = 1.0;
        color_distance = -1.0;
    }
    else
    {
        base_alpha = 0.0;
        color_distance = (input_rgb.r - input_rgb.g) + (input_rgb.b - input_rgb.g) + 2.0 * similarity;
        if(color_distance < 0.0)
        {
            color_distance = abs(color_distance) + 2.0 * similarity;
        }
    }
    
    return float2(base_alpha, color_distance);
}


float4 SampleTexture(float2 uv)
{
	return image.Sample(textureSampler, uv);
}

float2 GetBoxFilteredChromaDist(float3 rgb, float2 texCoord)
{
	float2 alpha_distance = get_base_alpha(rgb);
	alpha_distance += get_base_alpha(SampleTexture(texCoord-pixel_size).rgb);
	alpha_distance += get_base_alpha(SampleTexture(texCoord-float2(pixel_size.x, 0.0)).rgb);
	alpha_distance += get_base_alpha(SampleTexture(texCoord-float2(pixel_size.x, -pixel_size.y)).rgb);
	alpha_distance += get_base_alpha(SampleTexture(texCoord-float2(0.0, pixel_size.y)).rgb);
	alpha_distance += get_base_alpha(SampleTexture(texCoord+float2(0.0, pixel_size.y)).rgb);
	alpha_distance += get_base_alpha(SampleTexture(texCoord+float2(pixel_size.x, -pixel_size.y)).rgb);
	alpha_distance += get_base_alpha(SampleTexture(texCoord+float2(pixel_size.x, 0.0)).rgb);
	alpha_distance += get_base_alpha(SampleTexture(texCoord+pixel_size).rgb);	
	return alpha_distance / 9.0;
}

float alpha_smooth(float2 alpha_distance)
{
    float alpha          = alpha_distance[0];
    float color_distance = alpha_distance[1];
    
    float beta = 1.0 - alpha;  
    beta *= pow(saturate(color_distance / smoothness), 1.5);
    
    alpha = 1.0 - beta;
    
    return beta;
}


float3 spill_surpression(float3 rgb, float2 alpha_distance)
{
    float color_distance = alpha_distance[1];
    float spillVal = pow(saturate(color_distance / spill), 1.5);
    
    float y = (rgb.r * 0.2126 + rgb.g * 0.7152 + rgb.b * 0.0722);   
    
    return float3(y, y, y) * (1.0 - spillVal) + rgb * spillVal;
}


float4 ProcessChromaKey(float4 rgba, VertData v_in)
{
	
	float2 alpha_distance = GetBoxFilteredChromaDist(rgba.rgb, v_in.uv);	

	float smoothed_alpha = alpha_smooth(alpha_distance);	
	float3 spill_suppressed_rgb = spill_surpression(rgba.rgb, alpha_distance);

	return float4(spill_suppressed_rgb, smoothed_alpha);	
}

float4 PSChromaKeyRGBA(VertData v_in) : TARGET
{
	float4 rgba = image.Sample(textureSampler, v_in.uv) * color;	
	return ProcessChromaKey(rgba, v_in);
}

technique Draw
{
	pass
	{
		vertex_shader = VSDefault(v_in);
		pixel_shader  = PSChromaKeyRGBA(v_in);
	}
}
