#ifndef GL_ES
#extension GL_ARB_shader_texture_lod : require
#endif

varying	vec2 uv;
varying	vec3 normalWorld;
varying	vec3 tangentWorld;
varying	vec3 binormalWorld;
varying	vec3 posWorld;


uniform vec3 EyePos;
uniform vec4 EnvLightParam;
uniform vec4 PRRDifSHCoef[7];
uniform vec3 vDiffuseColor;
uniform float Roughness;
uniform float Metallic;

uniform sampler2D SamplerDiffuse;
uniform sampler2D SamplerNormal;
uniform sampler2D SamplerPBR;
uniform samplerCube 	PBR_Environment_Map;

vec3 Diffuse_Lambert( vec3 DiffuseColor )
{
	return DiffuseColor;
}

// [Schlick 1994, "An Inexpensive BRDF Model for Physically-Based Rendering"]
// [Lagarde 2012, "Spherical Gaussian approximation for Blinn-Phong, Phong and Fresnel"]
vec3 F_Schlick( vec3 SpecularColor, float VoH )
{
	float Fc = pow( 1 - VoH, 5 );							// 1 sub, 3 mul
	//float Fc = exp2( (-5.55473 * VoH - 6.98316) * VoH );	// 1 mad, 1 mul, 1 exp
	//return Fc + (1 - Fc) * SpecularColor;					// 1 add, 3 mad
	
	// Anything less than 2% is physically impossible and is instead considered to be shadowing
	return clamp( 50.0 * SpecularColor.g, 0.0, 1.0 ) * Fc + (1 - Fc) * SpecularColor;
	
}

// Appoximation of joint Smith term for GGX
// [Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"]
float Vis_SmithJointApprox( float Roughness, float NoV, float NoL )
{
	float a = Roughness * Roughness;
	float Vis_SmithV = NoL * ( NoV * ( 1 - a ) + a );
	float Vis_SmithL = NoV * ( NoL * ( 1 - a ) + a );
	return 0.5 / ( Vis_SmithV + Vis_SmithL );
}

// GGX / Trowbridge-Reitz
// [Walter et al. 2007, "Microfacet models for refraction through rough surfaces"]
float D_GGX( float Roughness, float NoH )
{
	float m = Roughness * Roughness;
	float m2 = m * m;
	float d = ( NoH * m2 - NoH ) * NoH + 1;	// 2 mad
	return m2 / ( d*d );					// 4 mul, 1 rcp
}

vec3 StandardShading( vec3 DiffuseColor, vec3 SpecularColor, float fRoughness, float fRoughnessY, vec2 LobeEnergy, vec3 L, vec3 V, vec3 N, vec3 T, vec3 B, vec2 DiffSpecMask )
{
	vec3 H = clamp(V + L, vec3(0.0), vec3(1.0));
	float NoL = clamp( dot(N, L), 0.0, 1.0 );
	//float NoV = clamp( dot(N, V), 0.0, 1.0 );
	float NoV = clamp( dot(N, V), 0.0, 1.0 ) + 1e-5;
	float NoH = clamp( dot(N, H), 0.0, 1.0 );
	float VoH = clamp( dot(V, H), 0.0, 1.0 );
	fRoughness = max( fRoughness, 0.08 );
	// Generalized microfacet specular
	float D = D_GGX( fRoughness, NoH ) * LobeEnergy.x;
	float Vis = Vis_SmithJointApprox( fRoughness, NoV, NoL );
	vec3 F = F_Schlick( SpecularColor, VoH );

	vec3 Diffuse = Diffuse_Lambert( DiffuseColor );
	//vec3 Diffuse = Diffuse_Burley( DiffuseColor, fRoughness, NoV, NoL, VoH );
	return Diffuse * (LobeEnergy.y * DiffSpecMask.r) + (D * Vis * DiffSpecMask.g) * F;
}

vec3 TexDirectxNormalMapRGBSampler( vec4 vColor )
{
	vColor.rgb = vColor.rgb * vec3( 2.0, 2.0, 2.0 ) - vec3( 1.0, 1.0, 1.0 );
	return vColor.rgb;
}

vec3 GetSHDiffuse(vec3 Normal, vec4 vDifSHCoef[7] )
{
	vec4 NormalVector = vec4(Normal.x, Normal.z, -Normal.y, 1);

	vec3 Intermediate0, Intermediate1, Intermediate2;
	Intermediate0.x = dot(vDifSHCoef[0], NormalVector);
	Intermediate0.y = dot(vDifSHCoef[1], NormalVector);
	Intermediate0.z = dot(vDifSHCoef[2], NormalVector);

	vec4 vB = NormalVector.xyzz * NormalVector.yzzx;
	Intermediate1.x = dot(vDifSHCoef[3], vB);
	Intermediate1.y = dot(vDifSHCoef[4], vB);
	Intermediate1.z = dot(vDifSHCoef[5], vB);

	float vC = NormalVector.x * NormalVector.x - NormalVector.y * NormalVector.y;
	Intermediate2 = vDifSHCoef[6].xyz * vC;

	// max to not get negative colors, maybe we can optimize to use saturate() and scale later or clamp this way: saturate(A/100)*100
	return max( vec3(0.0, 0.0, 0.0), Intermediate0 + Intermediate1 + Intermediate2 );
}

float ComputeCubemapMipFromRoughness( float Roughness, float MipCount )
{
	// Level starting from 1x1 mip
	return MipCount + EnvLightParam.w * log2( Roughness );
}

vec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )
{
	// [ Lazarov 2013, "Getting More Physical in Call of Duty: Black Ops II" ]
	// Adaptation to fit our G term.
	vec4 c0 = vec4(-1, -0.0275, -0.572, 0.022);
	vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );
	vec4 r = Roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
	vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
	AB.y *= clamp( 50.0 * SpecularColor.g, 0.0, 1.0 );
	return SpecularColor * AB.x + AB.y;
}

vec3 SamplerEvnCubemap( vec3 vTex, float fMipmapBias )
{
	vTex.y = -vTex.y;
#ifndef GL_ES
	vec4 rgbm = textureCubeLod(PBR_Environment_Map, vTex, fMipmapBias );
#else
	#if __VERSION__ >= 300
		vec4 rgbm = textureCubeLod(PBR_Environment_Map, vTex, fMipmapBias );
	#else
		vec4 rgbm = textureCube(PBR_Environment_Map, vTex );
	#endif
#endif
	return rgbm.rgb * rgbm.a * EnvLightParam.z;
}

void main()
{
	vec3 vEyeDir = normalize(EyePos.xyz - posWorld.xyz);
	vec3 vNormalOffset = TexDirectxNormalMapRGBSampler(texture2D(SamplerNormal, uv));
	//vec3 vNormalOffset = vec3(0.0, 0.0, 1.0);
	vec4 vPRR = texture2D(SamplerPBR, uv);
	//vec4 vPRR = vec4(Metallic, Roughness, 0.0, 0.0);
	vec4 diffuse_mtl = texture2D(SamplerDiffuse, uv);
	//vec4 diffuse_mtl = vec4( vDiffuseColor, 1.0 );

	diffuse_mtl.rgb = pow(diffuse_mtl.rgb, vec3(2.2));
	vec3 tangentWorld = normalize(tangentWorld);
	vec3 binormalWorld = normalize(binormalWorld);
	vec3 vNormalWorld = normalize( vNormalOffset.x * tangentWorld + vNormalOffset.y * binormalWorld + normalize(normalWorld) * vNormalOffset.z);
	
	float NoV = max( dot( vEyeDir, vNormalWorld), 0.0 );
	float fPBR_Roughness = max( vPRR.g, 0.08 );
	float fPRB_Metallic = vPRR.r;
	
	float fMinSpec = 0.08 * 0.5;
	vec3 specular_mtl = mix( vec3( fMinSpec, fMinSpec, fMinSpec ), diffuse_mtl.rgb, fPRB_Metallic );
	diffuse_mtl.rgb = diffuse_mtl.rgb * ( 1.0 - fPRB_Metallic );
	
	vec4 result;
	result.rgb = GetSHDiffuse(vNormalWorld, PRRDifSHCoef) * diffuse_mtl.rgb;
	
	vec3 vReflectionDir = reflect(-vEyeDir, vNormalWorld );
	vec3 SpecEnv = SamplerEvnCubemap( vReflectionDir, ComputeCubemapMipFromRoughness( fPBR_Roughness,EnvLightParam.x ) );
	result.xyz +=  SpecEnv * EnvBRDFApprox( specular_mtl, fPBR_Roughness, NoV );
	result.xyz = pow(result.xyz, vec3(1.0 / 2.2) );
	result.a = diffuse_mtl.a;
	gl_FragColor = result;
}
