uniform float4x4 ViewProj;
uniform texture2d image;
uniform texture2d fullMaskTex;
// uniform texture2d tex_baseimg;
uniform float4x4 yuv_mat = { 0.182586,  0.614231,  0.062007, 0.062745,
                            -0.100644, -0.338572,  0.439216, 0.501961,
                             0.439216, -0.398942, -0.040274, 0.501961,
                             0.000000,  0.000000,  0.000000, 1.000000};
uniform float similarity;
uniform float2 pixel_size;

uniform float mask_region_left;
uniform float mask_region_top;
uniform float mask_region_right;
uniform float mask_region_bottom;

uniform float unmask_region_left;
uniform float unmask_region_top;
uniform float unmask_region_right;
uniform float unmask_region_bottom;


uniform float color_r;
uniform float color_g;
uniform float color_b;
uniform int color_type;
uniform float top_color_value;
uniform float bottom_color_value;
uniform float smoothness;
uniform float spill;
float3 rgb2hsv(float3 c)
{
    float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    float4 p = lerp(float4(c.bg, K.wz), float4(c.gb, K.xy), step(c.b, c.g));
    float4 q = lerp(float4(p.xyw, c.r), float4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return float3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
}
sampler_state textureSampler {
	Filter    = Linear;
	AddressU  = Clamp;
	AddressV  = Clamp;
};

struct VertData {
	float4 pos : POSITION;
	float2 uv  : TEXCOORD0;
};

VertData VSDefault(VertData v_in)
{
	VertData vert_out;
	vert_out.pos = mul(float4(v_in.pos.xyz, 1.0), ViewProj);
	vert_out.uv  = v_in.uv;
	return vert_out;
}

float Region(float2 uv) {
	if ((uv.x >= unmask_region_left)
		&& (uv.x <= unmask_region_right)
		&& (uv.y >= unmask_region_top)
		&& (uv.y <= unmask_region_bottom)) {
		return 0.0;
	}

	if ((uv.x < mask_region_left)
		|| (uv.x > mask_region_right)
		|| (uv.y < mask_region_top)
		|| (uv.y > mask_region_bottom)) {
		return 0.0;
	}
	return 1.0;
}

float GetChromaDist(float3 rgb)
{
	float4 green_color = float4(color_r, color_g, color_b, 1.0);
    float2 chroma_key =  mul(float4(green_color.rgb, 1.0), yuv_mat).yz;
	float4 yuvx = mul(float4(rgb.rgb, 1.0), yuv_mat);
	return distance(chroma_key, yuvx.yz);
}

float4 SampleTexture(float2 uv)
{
	return image.Sample(textureSampler, uv);
}

float GetBoxFilteredChromaDist(float3 rgb, float2 texCoord)
{
	float distVal = GetChromaDist(rgb);
	distVal += GetChromaDist(SampleTexture(texCoord-pixel_size).rgb);
	distVal += GetChromaDist(SampleTexture(texCoord-float2(pixel_size.x, 0.0)).rgb);
	distVal += GetChromaDist(SampleTexture(texCoord-float2(pixel_size.x, -pixel_size.y)).rgb);

	distVal += GetChromaDist(SampleTexture(texCoord-float2(0.0, pixel_size.y)).rgb);
	distVal += GetChromaDist(SampleTexture(texCoord+float2(0.0, pixel_size.y)).rgb);

	distVal += GetChromaDist(SampleTexture(texCoord+float2(pixel_size.x, -pixel_size.y)).rgb);
	distVal += GetChromaDist(SampleTexture(texCoord+float2(pixel_size.x, 0.0)).rgb);
	distVal += GetChromaDist(SampleTexture(texCoord+pixel_size).rgb);
	return distVal / 9.0;
}

/* Despill by avg */
float3 despillByAvg(float3 rgb,float baseMask)
{
	float r = rgb.r;
	float g = rgb.g;
	float b = rgb.b;
	//float spillVal = pow(saturate(baseMask/spill),1.5);
	if (color_type == 1)
	{
		if( (b > ((r + g) / 2.0)) )
		{
			rgb.b = (r + g) / 2.0;
			return rgb;
		}
		else { //  其他颜色保持不变
			return rgb;
		}
	}
	else if (color_type == 2)
	{
		if( (r > ((b + g) / 2.0)) )
		{
			rgb.r = (b + g) / 2.0;
			return rgb;
		}
		else { //  其他颜色保持不变
			return rgb;
		}
	}
	else
	{
		float3 img_hsv = rgb2hsv(rgb.rgb);
		if( (g > ((r + b) / 2.0))  && (g - r > 10.0/255.0) && (g - b > 10.0/255.0))
		{
			//rgb.g = (r + b) / 2.0;
			if((img_hsv.x*360.0>bottom_color_value) &&(img_hsv.x*360.0<top_color_value)){
				float desat = r * 0.2126 + g * 0.7152 + b * 0.0722;
				rgb = saturate(float3(desat, desat, desat)*spill+rgb*(1-spill));
			}
			return rgb;
		}
		else { //  其他颜色保持不变
			return rgb;
		}
	}
	
}

// /* Despill by avg */
// float3 despillByAvg(float3 rgb)
// {
//     if(rgb.g > ((rgb.r + rgb.b) / 2.0))
//     {
//         rgb.g = (rgb.r + rgb.b) / 2.0;
//     }
//     return rgb;
// }

float4 ProcessChromaKey(float4 rgba, VertData v_in, float rect_mask)
{
	if (rect_mask <= 0.01)
	{
		return rgba;
	}
	float chromaDist = GetBoxFilteredChromaDist(rgba.rgb, v_in.uv);
	float baseMask = chromaDist - similarity;
	if((rgba.r > 1.5 * rgba.b) &&
	   (rgba.g > 1.5 * rgba.b) &&
	   (rgba.r > 100.0/255.0) &&
	   (rgba.g > 100.0/255.0)) // 黄颜色区域的透明度强制为1.0，保留黄色商品
	{
		baseMask = 1.0;
	}
	float fullMask = pow(saturate(baseMask / smoothness), 1.5);

	rgba.a *= fullMask;
	rgba.rgb = despillByAvg(rgba.rgb,baseMask);
    return rgba;
}

float4 PSChromaKeyRGBA(VertData v_in) : TARGET
{
	float rect_mask = Region(v_in.uv);
	float4 rgba = image.Sample(textureSampler, v_in.uv);
	return ProcessChromaKey(rgba, v_in, rect_mask);
}

float4 GetFullMaskFunc(float4 rgba, VertData v_in)
{
	float chromaDist = GetBoxFilteredChromaDist(rgba.rgb, v_in.uv);
	float baseMask = chromaDist - similarity;
	float fullMask = pow(saturate(baseMask / smoothness), 1.5);
    return float4(fullMask, fullMask, fullMask, fullMask);
}

float4 GetFullMaskProcess(VertData v_in) : TARGET
{
	float4 rgba = image.Sample(textureSampler, v_in.uv);
	return GetFullMaskFunc(rgba, v_in);
}

float4 DoNothing(VertData v_in) : TARGET
{
    return image.Sample(textureSampler, v_in.uv);
}

technique Draw
{
	pass
	{
		vertex_shader = VSDefault(v_in);
		pixel_shader  = PSChromaKeyRGBA(v_in);
	}
}


technique GetFullMask
{
	pass
	{
		vertex_shader = VSDefault(v_in);
		pixel_shader  = GetFullMaskProcess(v_in);
	}
}

technique DoNothing
{
	pass
	{
		vertex_shader = VSDefault(v_in);
		pixel_shader  = DoNothing(v_in);
	}
}

